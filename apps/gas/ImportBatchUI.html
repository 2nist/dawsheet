<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>
  body{font-family:Poppins,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fbf8f1;margin:12px;font-size:12px;color:#222}
  .card{background:#fff;border:1px solid #e3dccb;border-radius:10px;padding:10px;margin-bottom:10px}
  .btn{border:1px solid #cfc6ad;background:#fff;border-radius:8px;padding:6px 10px;cursor:pointer}
  .btn.primary{background:#2a74ff;color:#fff;border-color:#2a74ff}
  .muted{color:#666}
  .drop{border:2px dashed #cfc6ad;border-radius:10px;padding:16px;text-align:center;background:#fff}
  .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  .log{max-height:180px;overflow:auto;background:#fff;border:1px solid #e3dccb;border-radius:8px;padding:8px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:11px;white-space:pre-wrap}
</style>
</head>
<body>
  <?!= HtmlService.createHtmlOutputFromFile('midi_iife').getContent(); ?>

  <div class="card">
    <h3 style="margin:0 0 6px 0">Batch Import</h3>
  <div class="muted" style="margin-bottom:8px">Drop .json (chords/songs), .mid, .csv (lyrics), or .lab (annotations) files. Multiple files are supported.</div>
    <div id="drop" class="drop" ondragover="event.preventDefault()" ondrop="handleDrop(event)">
      Drag & drop files here<br>(or)
      <div class="row" style="justify-content:center;margin-top:8px">
  <input id="file" type="file" multiple accept=".json,.mid,.csv,.lab" />
        <button class="btn" onclick="pick()">Choose…</button>
      </div>
    </div>
    <div class="row" style="justify-content:flex-end;margin-top:8px">
      <button class="btn" onclick="clearLog()">Clear</button>
    </div>
    <div id="log" class="log"></div>
  </div>

<script>
function pick(){ document.getElementById('file').click(); }
document.getElementById('file').addEventListener('change', function(e){ handleFiles(e.target.files); });

function handleDrop(e){
  e.preventDefault();
  if (e.dataTransfer && e.dataTransfer.files) {
    handleFiles(e.dataTransfer.files);
  }
}

function clearLog(){ document.getElementById('log').textContent = ''; }
function log(s){ var el=document.getElementById('log'); el.textContent += s + '\n'; el.scrollTop = el.scrollHeight; }

async function handleFiles(fileList){
  var files = Array.from(fileList || []);
  if (!files.length){ log('No files.'); return; }
  log('Found ' + files.length + ' file(s).');
  // Prewarm server-side libraries once to avoid on-demand fetch storms
  try { await gasCall_('prewarmLibraries'); } catch(_) {}
  for (const f of files){
    try{
      const lname = f.name.toLowerCase();
      if (lname.endsWith('.json')){
        await importJsonFile(f);
      } else if (lname.endsWith('.mid')){
        await importMidiFile(f);
      } else if (lname.endsWith('.csv')){
        await importLyricsCsvFile(f);
      } else if (lname.endsWith('.lab')){
        await importLabFile(f);
      } else {
        log('Skip ' + f.name + ': unsupported extension.');
      }
    } catch(err){
      log('ERROR ' + f.name + ': ' + (err.message || err));
    }
  }
  log('Done.');
}

function readAsText(file){ return new Promise(function(res,rej){ var r=new FileReader(); r.onload=function(){res(r.result);}; r.onerror=function(){rej(r.error);}; r.readAsText(file); }); }
function readAsArrayBuffer(file){ return new Promise(function(res,rej){ var r=new FileReader(); r.onload=function(){res(r.result);}; r.onerror=function(){rej(r.error);}; r.readAsArrayBuffer(file); }); }

async function importJsonFile(file){
  log('JSON → ' + file.name);
  const txt = await readAsText(file);
  const hint = file.name.replace(/\.[^.]+$/, '');
  // Try client parse first; if both strict and cleaned fail, fall back to server tolerant parse
  let obj;
  try { obj = JSON.parse(txt); } catch(eStrict) {
    try { obj = JSON.parse(jsonClean_(txt)); } catch(eClean) { obj = null; }
  }
  try{
    const msg = obj
      ? await gasCall_('importChordJsonToSheets', obj, hint)
      : await gasCall_('importChordJsonRaw', txt, hint);
    log('OK ' + file.name + ': ' + msg);
  } catch(e){
    log('FAIL ' + file.name + ': ' + (e && e.message ? e.message : e));
  }
}

async function importLyricsCsvFile(file){
  log('CSV → ' + file.name);
  const txt = await readAsText(file);
  try{
    const msg = await gasCall_('importLyricsCsvRaw', txt);
    log('OK ' + file.name + ': ' + msg);
  } catch(e){
    log('FAIL ' + file.name + ': ' + (e && e.message ? e.message : e));
  }
}

async function importLabFile(file){
  log('LAB → ' + file.name);
  const txt = await readAsText(file);
  const hint = file.name.replace(/\.[^.]+$/, '');
  try{
    const msg = await gasCall_('importChordLabRaw', txt, hint);
    log('OK ' + file.name + ': ' + msg);
  } catch(e){
    log('FAIL ' + file.name + ': ' + (e && e.message ? e.message : e));
  }
}

async function importMidiFile(file){
  log('MIDI → ' + file.name);
  if (!window.MidiLib || typeof window.MidiLib.parse !== 'function'){
    if (window.MidiLib && window.MidiLib.ready) { await window.MidiLib.ready; }
    if (!window.MidiLib || typeof window.MidiLib.parse !== 'function'){
      throw new Error('MIDI parser not available (MidiLib).');
    }
  }
  const buf = await readAsArrayBuffer(file);
  let midi;
  try { midi = window.MidiLib.parse(new Uint8Array(buf)); }
  catch(e){ throw new Error('MIDI parse failed'); }

  const reduced = reduceMidi_(midi);
  const hint = file.name.replace(/\.[^.]+$/, '');
  try{
    const msg = await gasCall_('importMidiJsonToSheets', reduced, hint);
    log('OK ' + file.name + ': ' + msg);
  } catch(e){
    log('FAIL ' + file.name + ': ' + (e && e.message ? e.message : e));
  }
}

function reduceMidi_(midi){
  var ppq = (midi && midi.header && (midi.header.ppq || midi.header.ppqn)) || 480;
  var title = (midi && (midi.name || (midi.header && midi.header.name))) || '';
  var ts = '4/4', bpm = 120;
  try {
    // ToneJS Midi: header.timeSignatures [{ ticks, timeSignature:[n,d] }], header.tempos [{ bpm }]
    if (midi && midi.header) {
      if (Array.isArray(midi.header.timeSignatures) && midi.header.timeSignatures.length){
        var lastTs = midi.header.timeSignatures[midi.header.timeSignatures.length-1];
        if (lastTs && lastTs.timeSignature && lastTs.timeSignature.length>=2){ ts = lastTs.timeSignature[0] + '/' + lastTs.timeSignature[1]; }
      }
      if (Array.isArray(midi.header.tempos) && midi.header.tempos.length){
        var lastTmp = midi.header.tempos[midi.header.tempos.length-1];
        if (lastTmp && lastTmp.bpm) { bpm = Math.round(lastTmp.bpm); }
      }
    }
  } catch(_){ }
  var out = { meta:{ title: title, ppq: ppq, timeSignature: ts, bpm: bpm }, tracks: [] };
  (midi.tracks||[]).forEach(function(t,ti){
    var notes = (t.notes||[]).map(function(n){ return {
      time: n.ticks != null ? n.ticks : (n.time != null ? n.time : 0),
      duration: n.durationTicks != null ? n.durationTicks : (n.duration != null ? n.duration : 0),
      midi: n.midi != null ? n.midi : (n.noteNumber != null ? n.noteNumber : 60),
      velocity: Math.round(((n.velocity != null ? n.velocity : 0.8) * 127))
    }; });
    out.tracks.push({ name: t.name || ('Track ' + (ti+1)), channel: t.channel != null ? t.channel : 1, notes: notes });
  });
  return out;
}

// Remove BOM, // comments, /* */ comments, and trailing commas
function jsonClean_(s){
  let t = String(s || '');
  // BOM
  t = t.replace(/^\uFEFF/, '');
  // Block comments
  t = t.replace(/\/\*[\s\S]*?\*\//g, '');
  // Line comments
  t = t.replace(/(^|[^:\\])\/\/.*$/gm, '$1');
  // Trailing commas before ] or }
  t = t.replace(/,\s*([}\]])/g, '$1');
  return t;
}

// Promise wrapper for google.script.run calls; ensures sequential awaits in batch
function gasCall_(fnName){
  var args = Array.prototype.slice.call(arguments, 1);
  return new Promise(function(resolve, reject){
    google.script.run.withSuccessHandler(resolve).withFailureHandler(reject)[fnName].apply(google.script.run, args);
  });
}
</script>
</body>
</html>
